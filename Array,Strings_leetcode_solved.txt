// remove duplicate elements at most 2
    int removeDuplicates(vector<int>& nums) {
int i =0;
        // int ele= nums[0];
        for(auto ele : nums)
        {
            if(i==0 || i==1 || nums[i-2] != ele)
            {
                nums[i] = ele;
                i++;
            }
        }
    return i ;
       
        
       
    }


// majority element

    int majorityElement(vector<int>& nums) {

        map<int,int> m;
        //vector<int> ans;
        if(nums.size()==1){
            return nums[0];
        }
        for(int i=0;i<nums.size();i++){
            m[nums[i]]+=1;
            //ans.push_back(m[nums[i]]);

            if(m[nums[i]]>=(nums.size()/2+1) && nums.size()%2!=0){
                return nums[i];
            }
            
            if(m[nums[i]]>=(nums.size()/2) && nums.size()%2==0){
                return nums[i];
            }

        }

// rotate the array

void rotate(vector<int>& nums, int k) {
          k=k%nums.size();
        reverse(nums.begin(),nums.begin()+(nums.size()-k));

        reverse(nums.begin()+(nums.size()-k),nums.end());
    
        reverse(nums.begin(),nums.end());



    }

return 0;

3,2,1,4,5
3,2,1,5,4
4,5,1,2,3


// buy and sell stock
  int maxProfit(vector<int>& prices) {
         int min_price = prices[0];
        int maxprof = 0;

        for(int i=1;i<prices.size();i++){
            maxprof = max(maxprof,prices[i]-min_price);
            min_price = min(prices[i],min_price);
        }

        return maxprof;


    }


        
    }

// buy and sell stock II
 int maxProfit(vector<int>& prices) {

        int total_profit=0;
        int buy=prices[0];

        for(int i=1;i<prices.size();i++){
            if(buy>prices[i]){
                buy=prices[i];
            }

            else{
                total_profit+=prices[i]-buy;
                buy=prices[i];
            }
        }
        return total_profit;
    }
// Jump Game 1 (GREEDY) , here we calculate the highest jump=reachable , reachable is comapred everytime with the next array element's max jump, just run the code u will get it
  int reachable=0;
        for(int i=0;i<nums.size();i++){
            if(reachable<i){
                return false;
            }
            else{
                reachable=max(reachable,i+nums[i]);
            }
        }
        return true;
    }
// Jump Game 2 (GREEDY) // find the coverage which is window covering all the values that it can coverage
// when this coverge crosses or when this window covers the lastindex return the jump, here everytime we update the or insert a new cover we increment the jump so basically each cover indicates a jump.

int jump(vector<int>& nums) {
        int coverage=0;
        int lastindex=0;
        int jumps=0;

        if(nums.size()==1) return 0;

        for(int i=0;i<nums.size();i++){
          coverage=max(coverage,i+nums[i]);
            if(i==lastindex){
                lastindex=coverage;
                jumps++;
                
                 if(coverage>=nums.size()-1){
                return jumps;

            }

            }

           
        }
        return jumps;
    }
// H-index
  int hIndex(vector<int>& citations) {
         int n = citations.size();
        int low=0,high=n,mid;
        int res;
        sort(citations.begin(),citations.end());
        
        while(low<=high)
        {
            mid = low+(high-low)/2;
            int ub = lower_bound(citations.begin(),citations.end(),mid) - citations.begin();
            
            if(n-ub >= mid)
            {
                res = mid;
                low = mid+1;
            }
            else
                high = mid-1;
        }
        return res;
    }
// array product except itself element
vector<int> productExceptSelf(vector<int>& nums) {
 int n = nums.size();
        vector<int> ans(n);
        vector<int> left_Product(n);
        vector<int> right_Product(n);
        left_Product[0] = 1;
        for(int i=1; i<n; i++){
            left_Product[i] = left_Product[i-1] * nums[i-1];
        }
        right_Product[n-1] = 1;
        for(int i=n-2; i>=0; i--){
            right_Product[i] = right_Product[i+1] * nums[i+1];
        }
        for(int i=0; i<n; i++){
            ans[i] = left_Product[i] * right_Product[i];
        }
        return ans;
    }
// reverse a string 
 string reverseWords(string s) {
        string ans="";
        int l=s.length();
       
        while(s[l-1]==' '){
            l--;
        }
        int m=0;
        while(s[m]==' '){
            m++;
        }
        
        for(int i=l-1;i>=m;i--){
        
          string a="";
          while(s[i]!=' '){
             a+=s[i];
             i--;
          }
          reverse(a.begin(),a.end());
          ans+=a;
          ans+=' ';


        }

         return ans;
    }
